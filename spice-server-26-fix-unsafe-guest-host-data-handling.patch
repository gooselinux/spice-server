From fefe79a58df0a24c06c21783ddd5c09394e3ca12 Mon Sep 17 00:00:00 2001
From: Izik Eidus <ieidus@redhat.com>
Date: Sat, 13 Mar 2010 10:40:56 +0200
Subject: [PATCH 1/4] spice server: fix unsafe guest/host data handling #568811

Signed-off-by: Izik Eidus <ieidus@redhat.com>
---
 server/red_worker.c |  752 +++++++++++++++++++++++++++++++++++----------------
 server/red_yuv.h    |   14 +-
 2 files changed, 526 insertions(+), 240 deletions(-)

diff --git a/server/red_worker.c b/server/red_worker.c
index 9ffd7c1..278b20f 100644
--- a/server/red_worker.c
+++ b/server/red_worker.c
@@ -511,6 +511,16 @@ typedef struct FreeList {

 typedef struct DisplayChannel DisplayChannel;

+typedef void *(*enc_get_virt_fn_t)(void *get_virt_opaque, unsigned long addr, uint32_t add_size);
+typedef void (*enc_validate_virt_fn_t)(void *validate_virt_opaque, unsigned long virt, uint32_t add_size);
+
+static inline void check_mul_overflow(uint32_t a, uint32_t b)
+{
+    if (((uint64_t)a * b) > (uint32_t)(-1)) {
+        PANIC("mul is overflowed");
+    }
+}
+
 typedef struct  {
     DisplayChannel *display_channel;
     RedCompressBuf *bufs_head;
@@ -519,8 +529,12 @@ typedef struct  {
     union {
         struct {
             ADDRESS next;
-            long address_delta;
             uint32_t stride;
+
+            void *enc_get_virt_opaque;
+            enc_get_virt_fn_t enc_get_virt;
+            void *enc_validate_virt_opaque;
+            enc_validate_virt_fn_t enc_validate_virt;
         } lines_data;
         struct {
             uint8_t* next;
@@ -806,7 +820,6 @@ typedef struct UpgradeItem {
     QRegion region;
 } UpgradeItem;

-typedef void (*set_access_params_t)(void *canvas, ADDRESS delta);
 typedef void (*draw_fill_t)(void *canvas, Rect *bbox, Clip *clip, Fill *fill);
 typedef void (*draw_copy_t)(void *canvas, Rect *bbox, Clip *clip, Copy *copy);
 typedef void (*draw_opaque_t)(void *canvas, Rect *bbox, Clip *clip, Opaque *opaque);
@@ -830,7 +843,6 @@ typedef void (*destroy_t)(void *canvas);
 typedef struct DrawContext {
     void *canvas;
     int top_down;
-    set_access_params_t set_access_params;
     draw_fill_t draw_fill;
     draw_copy_t draw_copy;
     draw_opaque_t draw_opaque;
@@ -869,6 +881,12 @@ typedef struct ItemTrace {

 #endif

+typedef struct TrustedHostVirtItem {
+    RingItem link;
+    unsigned long virt_start;
+    unsigned long virt_end;
+} TrustedHostVirtItem;
+
 #define NUM_DRAWABLES 1000

 typedef struct RedWorker {
@@ -949,6 +967,8 @@ typedef struct RedWorker {
     uint64_t *wakeup_counter;
     uint64_t *command_counter;
 #endif
+
+    Ring trusted_host_virts;
 } RedWorker;

 pthread_mutex_t avcodec_lock = PTHREAD_MUTEX_INITIALIZER;
@@ -1034,6 +1054,46 @@ static void print_compress_stats(DisplayChannel *display_channel)

 #endif

+static inline int is_virt_is_host_trusted(RedWorker *worker, unsigned long virt, uint32_t add_size);
+
+static inline void validate_virt(RedWorker *worker, unsigned long virt, uint32_t add_size)
+{
+    if ((virt + add_size) < virt) {
+        PANIC("virtual address overlap");
+    }
+
+    if (virt < worker->dev_info.phys_start || (virt + add_size) > worker->dev_info.phys_end) {
+        if (!is_virt_is_host_trusted(worker, virt, add_size)) {
+            PANIC("virtual address out of range\n");
+        }
+    }
+}
+
+static inline unsigned long get_virt_delta(RedWorker *worker)
+{
+    return worker->dev_info.phys_delta;
+}
+
+static inline unsigned long get_virt(RedWorker *worker, unsigned long addr, uint32_t add_size)
+{
+    unsigned long h_virt;
+
+    h_virt =  addr + worker->dev_info.phys_delta;
+    validate_virt(worker, h_virt, add_size);
+
+    return h_virt;
+}
+
+static void *cb_get_virt(void *opaque, unsigned long addr, uint32_t add_size)
+{
+    return (void *)get_virt((RedWorker *)opaque, addr, add_size);
+}
+
+static void cb_validate_virt(void *opaque, unsigned long virt, uint32_t add_size)
+{
+    validate_virt((RedWorker *)opaque, virt, add_size);
+}
+
 char *draw_type_to_str(UINT8 type)
 {
     switch (type) {
@@ -1216,14 +1276,71 @@ static inline void red_pipe_add_image_item(RedWorker *worker, ImageItem *item)
     red_pipe_add(&worker->display_channel->base, &item->link);
 }

+static inline void red_trusted_host_virts_add(RedWorker *worker, unsigned long virt, uint32_t size)
+{
+    TrustedHostVirtItem *item = malloc(sizeof(TrustedHostVirtItem));
+    if (!item) {
+        PANIC("malloc failed");
+    }
+    ring_item_init(&item->link);
+    item->virt_start = virt;
+    item->virt_end = item->virt_start + size;
+    ring_add(&worker->trusted_host_virts, &item->link);
+}
+
+static inline TrustedHostVirtItem *red_get_host_trusted_item(RedWorker *worker, unsigned long virt)
+{
+    Ring *ring = &worker->trusted_host_virts;
+    RingItem *ring_item = ring;
+    TrustedHostVirtItem *item;
+
+    while ((ring_item = ring_next(ring, ring_item))) {
+        item = CONTAINEROF(ring_item, TrustedHostVirtItem, link);
+        if (virt >= item->virt_start && virt < item->virt_end) {
+            return item;
+        }
+    }
+    return NULL;
+}
+
+static inline void red_trusted_host_virts_del(RedWorker *worker, unsigned long virt)
+{
+    TrustedHostVirtItem *item;
+
+    item = red_get_host_trusted_item(worker, virt);
+    if (!item) {
+        PANIC("trusted_host_virts list corruptio");
+    }
+
+    ring_remove(&item->link);
+    free(item);
+}
+
+static inline int is_virt_is_host_trusted(RedWorker *worker, unsigned long virt, uint32_t add_size)
+{
+    TrustedHostVirtItem *item;
+
+    item = red_get_host_trusted_item(worker, virt);
+    if (!item) {
+        return FALSE;
+    }
+
+    if (virt >= item->virt_start && (virt + add_size) <= item->virt_end) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 static inline uint64_t channel_message_serial(RedChannel *channel)
 {
     return channel->send_data.header.serial;
 }

-static void release_image_item(ImageItem *item)
+static void release_image_item(RedWorker *worker, ImageItem *item)
 {
     if (!--item->refs) {
+        red_trusted_host_virts_del(worker, (unsigned long)item);
         free(item);
     }
 }
@@ -1278,9 +1395,11 @@ static void red_pipe_clear_device_resources(RedChannel *channel)

 static void red_pipe_clear(RedChannel *channel)
 {
+    RedWorker *worker;
     PipeItem *item;

     ASSERT(channel);
+    worker = channel->worker;
     while ((item = (PipeItem *)ring_get_head(&channel->pipe))) {
         ring_remove(&item->link);
         switch (item->type) {
@@ -1307,7 +1426,7 @@ static void red_pipe_clear(RedChannel *channel)
             free(item);
             break;
         case PIPE_ITEM_TYPE_IMAGE:
-            release_image_item((ImageItem *)item);
+            release_image_item(worker, (ImageItem *)item);
             break;
         case PIPE_ITEM_TYPE_STREAM_CREATE:
             red_display_release_stream((DisplayChannel *)channel,
@@ -1379,6 +1498,7 @@ static inline void free_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     if (drawable->bitmap_offset) {
         PHYSICAL *addr = (PHYSICAL *)((uint8_t *)drawable + drawable->bitmap_offset);
         if (*addr) {
+            red_trusted_host_virts_del(worker, (unsigned long)*addr);
             free((uint8_t *)*addr + worker->dev_info.phys_delta);
         }
     }
@@ -1935,7 +2055,7 @@ static inline void __current_add_drawable(RedWorker *worker, Drawable *drawable,

 #ifdef USE_EXCLUDE_RGN

-static int is_equal_path(ADDRESS p1, ADDRESS p2, long phys_delta)
+static int is_equal_path(RedWorker *worker, ADDRESS p1, ADDRESS p2)
 {
     QXLPath *path1;
     QXLPath *path2;
@@ -1949,8 +2069,8 @@ static int is_equal_path(ADDRESS p1, ADDRESS p2, long phys_delta)

     ASSERT(p1 && p2);

-    path1 = (QXLPath *)(p1 + phys_delta);
-    path2 = (QXLPath *)(p2 + phys_delta);
+    path1 = (QXLPath *)get_virt(worker, p1, sizeof(QXLPath));
+    path2 = (QXLPath *)get_virt(worker, p2, sizeof(QXLPath));

     if ((size = path1->data_size) != path2->data_size) {
         return FALSE;
@@ -1976,7 +2096,7 @@ static int is_equal_path(ADDRESS p1, ADDRESS p2, long phys_delta)
         }
         if ((size1 -= now) == 0) {
             ASSERT(chunk1->next_chunk)
-            chunk1 = (QXLDataChunk *)(chunk1->next_chunk + phys_delta);
+            chunk1 = (QXLDataChunk *)get_virt(worker, chunk1->next_chunk, sizeof(QXLDataChunk));
             size1 = chunk1->data_size;
             data1 = chunk1->data;
         } else {
@@ -1985,7 +2105,7 @@ static int is_equal_path(ADDRESS p1, ADDRESS p2, long phys_delta)

         if ((size2 -= now) == 0) {
             ASSERT(chunk2->next_chunk)
-            chunk2 = (QXLDataChunk *)(chunk2->next_chunk + phys_delta);
+            chunk2 = (QXLDataChunk *)get_virt(worker, chunk2->next_chunk, sizeof(QXLDataChunk));
             size2 = chunk2->data_size;
             data2 = chunk2->data;
         } else {
@@ -2016,7 +2136,7 @@ static inline int rect_is_equal(const Rect *r1, const Rect *r2)
 }

 // partial imp
-static int is_same_geometry(QXLDrawable *d1, QXLDrawable *d2, long phys_delta)
+static int is_same_geometry(RedWorker *worker, QXLDrawable *d1, QXLDrawable *d2)
 {
     if (d1->type != d2->type) {
         return FALSE;
@@ -2025,7 +2145,7 @@ static int is_same_geometry(QXLDrawable *d1, QXLDrawable *d2, long phys_delta)
     switch (d1->type) {
     case QXL_DRAW_STROKE:
         return is_equal_line_attr(&d1->u.stroke.attr, &d2->u.stroke.attr) &&
-               is_equal_path(d1->u.stroke.path, d2->u.stroke.path, phys_delta);
+               is_equal_path(worker, d1->u.stroke.path, d2->u.stroke.path);
     case QXL_DRAW_FILL:
         return rect_is_equal(&d1->bbox, &d2->bbox);
     default:
@@ -2033,9 +2153,9 @@ static int is_same_geometry(QXLDrawable *d1, QXLDrawable *d2, long phys_delta)
     }
 }

-static int is_same_drawable(QXLDrawable *d1, QXLDrawable *d2, long phys_delta)
+static int is_same_drawable(RedWorker *worker, QXLDrawable *d1, QXLDrawable *d2)
 {
-    if (!is_same_geometry(d1, d2, phys_delta)) {
+    if (!is_same_geometry(worker, d1, d2)) {
         return FALSE;
     }

@@ -2503,8 +2623,8 @@ static void red_create_stream(RedWorker *worker, Drawable *drawable)
     stream->av_frame = frame;
     stream->frame_buf = frame_buf;
     stream->frame_buf_end = frame_buf + pict_size;
-    QXLImage *qxl_image = (QXLImage *)(drawable->qxl_drawable->u.copy.src_bitmap +
-                                       worker->dev_info.phys_delta);
+    QXLImage *qxl_image = (QXLImage *)get_virt(worker, drawable->qxl_drawable->u.copy.src_bitmap,
+                                               sizeof(QXLImage));
     stream->top_down = !!(qxl_image->bitmap.flags & BITMAP_TOP_DOWN);
     drawable->stream = stream;

@@ -2577,13 +2697,13 @@ static void red_init_streams(RedWorker *worker)

 #ifdef STREAM_TRACE

-static inline int __red_is_next_stream_frame(const Drawable *candidate,
+static inline int __red_is_next_stream_frame(RedWorker *worker,
+                                             const Drawable *candidate,
                                              const int other_src_width,
                                              const int other_src_height,
                                              const Rect *other_dest,
                                              const red_time_t other_time,
-                                             const Stream *stream,
-                                             unsigned long phys_delta)
+                                             const Stream *stream)
 {
     QXLDrawable *qxl_drawable;

@@ -2605,7 +2725,8 @@ static inline int __red_is_next_stream_frame(const Drawable *candidate,
     }

     if (stream) {
-        QXLImage *qxl_image = (QXLImage *)(qxl_drawable->u.copy.src_bitmap + phys_delta);
+        QXLImage *qxl_image = (QXLImage *)get_virt(worker, qxl_drawable->u.copy.src_bitmap,
+                                                   sizeof(QXLImage));

         if (stream->top_down != !!(qxl_image->bitmap.flags & BITMAP_TOP_DOWN)) {
             return FALSE;
@@ -2614,24 +2735,22 @@ static inline int __red_is_next_stream_frame(const Drawable *candidate,
     return TRUE;
 }

-static inline int red_is_next_stream_frame(const Drawable *candidate, const Drawable *prev,
-                                           const unsigned long phys_delta)
+static inline int red_is_next_stream_frame(RedWorker *worker, const Drawable *candidate, const Drawable *prev)
 {
     if (!candidate->streamable) {
         return FALSE;
     }

     Rect* prev_src = &prev->qxl_drawable->u.copy.src_area;
-    return __red_is_next_stream_frame(candidate, prev_src->right - prev_src->left,
+    return __red_is_next_stream_frame(worker, candidate, prev_src->right - prev_src->left,
                                       prev_src->bottom - prev_src->top,
                                       &prev->qxl_drawable->bbox, prev->creation_time,
-                                      prev->stream, phys_delta);
+                                      prev->stream);
 }

 #else

-static inline int red_is_next_stream_frame(Drawable *candidate, Drawable *prev,
-                                           unsigned long phys_delta)
+static inline int red_is_next_stream_frame(RedWorker *worker, Drawable *candidate, Drawable *prev)
 {
     QXLImage *qxl_image;
     QXLDrawable *qxl_drawable;
@@ -2661,7 +2780,7 @@ static inline int red_is_next_stream_frame(Drawable *candidate, Drawable *prev,
         return FALSE;
     }

-    qxl_image = (QXLImage *)(qxl_drawable->u.copy.src_bitmap + phys_delta);
+    qxl_image = (QXLImage *)get_virt(worker, qxl_drawable->u.copy.src_bitmap, sizeof(QXLImage));

     if (qxl_image->descriptor.type != IMAGE_TYPE_BITMAP) {
         return FALSE;
@@ -2754,7 +2873,8 @@ static inline void red_update_copy_graduality(RedWorker* worker, Drawable *drawa
     qxl_image = (QXLImage *)(drawable->qxl_drawable->u.copy.src_bitmap +
                              worker->dev_info.phys_delta);

-    if (!BITMAP_FMT_IS_RGB[qxl_image->bitmap.format] || _stride_is_extra(&qxl_image->bitmap) ||
+    if (!BITMAP_FMT_IS_RGB[MIN(qxl_image->bitmap.format, sizeof(BITMAP_FMT_IS_RGB) / sizeof(int))] ||
+        _stride_is_extra(&qxl_image->bitmap) ||
         (qxl_image->bitmap.flags & QXL_BITMAP_UNSTABLE)) {
         drawable->copy_bitmap_graduality = BITMAP_GRADUAL_NOT_AVAIL;
     } else  {
@@ -2806,14 +2926,15 @@ static inline void red_stream_maintenance(RedWorker *worker, Drawable *candidate
     }

 #ifdef STREAM_TRACE
-    if (!red_is_next_stream_frame(candidate, prev, worker->dev_info.phys_delta)) {
+    if (!red_is_next_stream_frame(worker, candidate, prev)) {
         return;
     }
 #else
     if (!worker->streaming_video ||
-                        !red_is_next_stream_frame(candidate, prev, worker->dev_info.phys_delta)) {
+                        !red_is_next_stream_frame(worker, candidate, prev)) {
+elta)) {
     if ((worker->streaming_video == SPICE_STREAM_VIDEO_OFF) ||
-                         !red_is_next_stream_frame(candidate, prev, worker->dev_info.phys_delta) {
+                         !red_is_next_stream_frame(worker, candidate, prev)) {
         return;
     }
 #endif
@@ -2888,7 +3009,7 @@ static inline int red_current_add_equal(RedWorker *worker, DrawItem *item, TreeI

     switch (item->effect) {
     case QXL_EFFECT_REVERT_ON_DUP:
-        if (is_same_drawable(qxl_drawable, other_qxl_drawable, worker->dev_info.phys_delta)) {
+        if (is_same_drawable(worker, qxl_drawable, other_qxl_drawable)) {
             if (!ring_item_is_linked(&other_drawable->pipe_item.link)) {
                 red_pipe_add_drawable(worker, drawable);
             }
@@ -2897,7 +3018,7 @@ static inline int red_current_add_equal(RedWorker *worker, DrawItem *item, TreeI
         }
         break;
     case QXL_EFFECT_OPAQUE_BRUSH:
-        if (is_same_geometry(qxl_drawable, other_qxl_drawable, worker->dev_info.phys_delta)) {
+        if (is_same_geometry(worker, qxl_drawable, other_qxl_drawable)) {
             __current_add_drawable(worker, drawable, &other->siblings_link);
             remove_drawable(worker, other_drawable);
             red_pipe_add_drawable(worker, drawable);
@@ -2905,7 +3026,7 @@ static inline int red_current_add_equal(RedWorker *worker, DrawItem *item, TreeI
         }
         break;
     case QXL_EFFECT_NOP_ON_DUP:
-        if (is_same_drawable(qxl_drawable, other_qxl_drawable, worker->dev_info.phys_delta)) {
+        if (is_same_drawable(worker, qxl_drawable, other_qxl_drawable)) {
             return TRUE;
         }
         break;
@@ -2932,13 +3053,13 @@ static inline void red_use_stream_trace(RedWorker *worker, Drawable *drawable)

     while (item) {
         Stream *stream = CONTAINEROF(item, Stream, link);
-        if (!stream->current && __red_is_next_stream_frame(drawable,
+        if (!stream->current && __red_is_next_stream_frame(worker,
+                                                           drawable,
                                                            stream->width,
                                                            stream->height,
                                                            &stream->dest_area,
                                                            stream->last_time,
-                                                           stream,
-                                                           worker->dev_info.phys_delta)) {
+                                                           stream)) {
             red_attach_stream(worker, drawable, stream);
             return;
         }
@@ -2948,8 +3069,8 @@ static inline void red_use_stream_trace(RedWorker *worker, Drawable *drawable)
     trace = worker->items_trace;
     trace_end = trace + NUM_TRACE_ITEMS;
     for (; trace < trace_end; trace++) {
-        if (__red_is_next_stream_frame(drawable, trace->width, trace->height,
-                              &trace->dest_area, trace->time, NULL, worker->dev_info.phys_delta)) {
+        if (__red_is_next_stream_frame(worker, drawable, trace->width, trace->height,
+                              &trace->dest_area, trace->time, NULL)) {
             red_stream_add_frame(worker, drawable,
                                  trace->frames_count,
                                  trace->gradual_frames_count,
@@ -3196,15 +3317,18 @@ static inline int red_current_add(RedWorker *worker, Drawable *drawable)

 #endif

-static void add_clip_rects(QRegion *rgn, PHYSICAL data, unsigned long phys_delta)
+static void add_clip_rects(RedWorker *worker, QRegion *rgn, PHYSICAL data)
 {
     while (data) {
         QXLDataChunk *chunk;
         Rect *now;
         Rect *end;
-        chunk = (QXLDataChunk *)(data + phys_delta);
+        uint32_t data_size;
+        chunk = (QXLDataChunk *)get_virt(worker, data, sizeof(QXLDataChunk));
+        data_size = chunk->data_size;
+        validate_virt(worker, (unsigned long)chunk->data, data_size);
         now = (Rect *)chunk->data;
-        end = now + chunk->data_size / sizeof(Rect);
+        end = now + data_size / sizeof(Rect);

         for (; now < end; now++) {
             Rect* r = (Rect *)now;
@@ -3311,7 +3435,7 @@ static inline void red_update_streamable(RedWorker *worker, Drawable *drawable,
         return;
     }

-    qxl_image = (QXLImage *)(qxl_drawable->u.copy.src_bitmap + worker->dev_info.phys_delta);
+    qxl_image = (QXLImage *)get_virt(worker, qxl_drawable->u.copy.src_bitmap, sizeof(QXLImage));
     if (qxl_image->descriptor.type != IMAGE_TYPE_BITMAP) {
         return;
     }
@@ -3411,6 +3535,7 @@ static inline int red_handle_self_bitmap(RedWorker *worker, QXLDrawable *drawabl
         return FALSE;
     }
     dest = (uint8_t *)(image + 1);
+    red_trusted_host_virts_add(worker, (unsigned long)image, sizeof(QXLImage) + height * dest_stride);

     image->descriptor.type = IMAGE_TYPE_BITMAP;
     image->descriptor.flags = 0;
@@ -3498,8 +3623,7 @@ static inline void red_process_drawable(RedWorker *worker, QXLDrawable *drawable
         QRegion rgn;

         region_init(&rgn);
-        add_clip_rects(&rgn, drawable->clip.data + OFFSETOF(QXLClipRects, chunk),
-                       worker->dev_info.phys_delta);
+        add_clip_rects(worker, &rgn, drawable->clip.data + OFFSETOF(QXLClipRects, chunk));
         region_and(&item->tree_item.base.rgn, &rgn);
         region_destroy(&rgn);
     } else if (drawable->clip.type == CLIP_TYPE_PATH) {
@@ -3532,14 +3656,15 @@ static inline void red_process_drawable(RedWorker *worker, QXLDrawable *drawable
     release_drawable(worker, item);
 }

-static void localize_path(PHYSICAL *in_path, long phys_delta)
+static void localize_path(RedWorker *worker, PHYSICAL *in_path)
 {
     QXLPath *path;
     uint8_t *data;
+    uint32_t data_size;
     QXLDataChunk *chunk;

     ASSERT(in_path && *in_path);
-    path = (QXLPath *)(*in_path + phys_delta);
+    path = (QXLPath *)get_virt(worker, *in_path, sizeof(QXLPath));
     data = malloc(sizeof(UINT32) + path->data_size);
     ASSERT(data);
     *in_path = (PHYSICAL)data;
@@ -3547,9 +3672,12 @@ static void localize_path(PHYSICAL *in_path, long phys_delta)
     data += sizeof(UINT32);
     chunk = &path->chunk;
     do {
-        memcpy(data, chunk->data, chunk->data_size);
-        data += chunk->data_size;
-        chunk = chunk->next_chunk ? (QXLDataChunk *)(chunk->next_chunk + phys_delta) : NULL;
+        data_size = chunk->data_size;
+        validate_virt(worker, (unsigned long)chunk->data, data_size);
+        memcpy(data, chunk->data, data_size);
+        data += data_size;
+        chunk = chunk->next_chunk ? (QXLDataChunk *)get_virt(worker, chunk->next_chunk,
+                                                             sizeof(QXLDataChunk)) : NULL;
     } while (chunk);
 }

@@ -3560,12 +3688,13 @@ static void unlocalize_path(PHYSICAL *path)
     *path = 0;
 }

-static void localize_str(PHYSICAL *in_str, long phys_delta)
+static void localize_str(RedWorker *worker, PHYSICAL *in_str)
 {
-    QXLString *qxl_str = (QXLString *)(*in_str + phys_delta);
+    QXLString *qxl_str = (QXLString *)get_virt(worker, *in_str, sizeof(QXLString));
     QXLDataChunk *chunk;
     String *str;
     uint8_t *dest;
+    uint32_t data_size;

     ASSERT(in_str);
     str = malloc(sizeof(UINT32) + qxl_str->data_size);
@@ -3576,12 +3705,14 @@ static void localize_str(PHYSICAL *in_str, long phys_delta)
     dest = str->data;
     chunk = &qxl_str->chunk;
     for (;;) {
-        memcpy(dest, chunk->data, chunk->data_size);
+        data_size = chunk->data_size;
+        validate_virt(worker, (unsigned long)chunk->data, data_size);
+        memcpy(dest, chunk->data, data_size);
         if (!chunk->next_chunk) {
             return;
         }
-        dest += chunk->data_size;
-        chunk = (QXLDataChunk *)(chunk->next_chunk + phys_delta);
+        dest += data_size;
+        chunk = (QXLDataChunk *)get_virt(worker, chunk->next_chunk, sizeof(QXLDataChunk));
     }
 }

@@ -3592,7 +3723,7 @@ static void unlocalize_str(PHYSICAL *str)
     *str = 0;
 }

-static void localize_clip(Clip *clip, long phys_delta)
+static void localize_clip(RedWorker *worker, Clip *clip)
 {
     switch (clip->type) {
     case CLIP_TYPE_NONE:
@@ -3601,7 +3732,8 @@ static void localize_clip(Clip *clip, long phys_delta)
         QXLClipRects *clip_rects;
         QXLDataChunk *chunk;
         uint8_t *data;
-        clip_rects = (QXLClipRects *)(clip->data + phys_delta);
+        uint32_t data_size;
+        clip_rects = (QXLClipRects *)get_virt(worker, clip->data, sizeof(QXLClipRects));
         chunk = &clip_rects->chunk;
         ASSERT(clip->data);
         data = malloc(sizeof(UINT32) + clip_rects->num_rects * sizeof(Rect));
@@ -3610,14 +3742,17 @@ static void localize_clip(Clip *clip, long phys_delta)
         *(UINT32 *)(data) = clip_rects->num_rects;
         data += sizeof(UINT32);
         do {
-            memcpy(data, chunk->data, chunk->data_size);
-            data += chunk->data_size;
-            chunk = chunk->next_chunk ? (QXLDataChunk *)(chunk->next_chunk + phys_delta) : NULL;
+            data_size = chunk->data_size;
+            validate_virt(worker, (unsigned long)chunk->data, data_size);
+            memcpy(data, chunk->data, data_size);
+            data += data_size;
+            chunk = chunk->next_chunk ? (QXLDataChunk *)get_virt(worker, chunk->next_chunk,
+                                                                 sizeof(QXLDataChunk)) : NULL;
         } while (chunk);
         break;
     }
     case CLIP_TYPE_PATH:
-        localize_path(&clip->data, phys_delta);
+        localize_path(worker, &clip->data);
         break;
     default:
         red_printf("invalid clip type");
@@ -3777,13 +3912,13 @@ static void image_cache_eaging(ImageCache *cache)
 #endif
 }

-static void localize_bitmap(RedWorker *worker, PHYSICAL *in_bitmap, long phys_delta)
+static void localize_bitmap(RedWorker *worker, PHYSICAL *in_bitmap)
 {
     QXLImage *image;
     QXLImage *local_image;

     ASSERT(in_bitmap && *in_bitmap);
-    image = (QXLImage *)(*in_bitmap + phys_delta);
+    image = (QXLImage *)get_virt(worker, *in_bitmap, sizeof(QXLImage));
     local_image = (QXLImage *)alloc_local_image(worker);
     *local_image = *image;
     *in_bitmap = (PHYSICAL)local_image;
@@ -3810,7 +3945,9 @@ static void localize_bitmap(RedWorker *worker, PHYSICAL *in_bitmap, long phys_de
     }
     case IMAGE_TYPE_BITMAP:
         if (image->bitmap.flags & QXL_BITMAP_DIRECT) {
-            local_image->bitmap.data = (PHYSICAL)(image->bitmap.data + phys_delta);
+            check_mul_overflow(image->bitmap.stride, image->bitmap.y);
+            local_image->bitmap.data = (PHYSICAL)get_virt(worker, image->bitmap.data,
+                                                          image->bitmap.stride * image->bitmap.y);
         } else {
             PHYSICAL src_data;
             int size = image->bitmap.y * image->bitmap.stride;
@@ -3821,11 +3958,14 @@ static void localize_bitmap(RedWorker *worker, PHYSICAL *in_bitmap, long phys_de

             while (size) {
                 QXLDataChunk *chunk;
+                uint32_t data_size;
                 int cp_size;

                 ASSERT(src_data);
-                chunk = (QXLDataChunk *)(src_data + phys_delta);
-                cp_size = MIN(chunk->data_size, size);
+                chunk = (QXLDataChunk *)get_virt(worker, src_data, sizeof(QXLDataChunk));
+                data_size = chunk->data_size;
+                validate_virt(worker, (unsigned long)chunk->data, data_size);
+                cp_size = MIN(data_size, size);
                 memcpy(data, chunk->data, cp_size);
                 data += cp_size;
                 size -= cp_size;
@@ -3834,7 +3974,30 @@ static void localize_bitmap(RedWorker *worker, PHYSICAL *in_bitmap, long phys_de
         }

         if (local_image->bitmap.palette) {
-            local_image->bitmap.palette = (local_image->bitmap.palette + phys_delta);
+            uint16_t num_ents;
+            uint32_t *ents;
+            Palette *tmp_palette;
+            Palette *shadow_palette;
+
+            tmp_palette = (Palette *)get_virt(worker, local_image->bitmap.palette, sizeof(Palette));
+
+            num_ents = tmp_palette->num_ents;
+            ents = tmp_palette->ents;
+
+            check_mul_overflow(num_ents, sizeof(uint32_t));
+            validate_virt(worker, (unsigned long)ents, (num_ents * sizeof(uint32_t)));
+
+            shadow_palette = (Palette *)malloc(sizeof(Palette) + num_ents * sizeof(uint32_t) +
+                                               sizeof(PHYSICAL));
+            if (!shadow_palette) {
+                PANIC("Palette malloc failed");
+            }
+
+            memcpy(shadow_palette->ents, ents, num_ents * sizeof(uint32_t));
+            shadow_palette->num_ents = num_ents;
+            shadow_palette->unique = tmp_palette->unique;
+
+            local_image->bitmap.palette = (ADDRESS)shadow_palette;
         }
         break;
     default:
@@ -3855,6 +4018,9 @@ static void unlocalize_bitmap(PHYSICAL *bitmap)
         if (!(image->bitmap.flags & QXL_BITMAP_DIRECT)) {
             free((void *)image->bitmap.data);
         }
+        if (image->bitmap.palette) {
+            free((void *)image->bitmap.palette);
+        }
         break;
     case IMAGE_TYPE_QUIC:
     case IMAGE_TYPE_FROM_CACHE:
@@ -3865,10 +4031,10 @@ static void unlocalize_bitmap(PHYSICAL *bitmap)
     }
 }

-static void localize_brush(RedWorker *worker, Brush *brush, long phys_delta)
+static void localize_brush(RedWorker *worker, Brush *brush)
 {
     if (brush->type == BRUSH_TYPE_PATTERN) {
-        localize_bitmap(worker, &brush->u.pattern.pat, phys_delta);
+        localize_bitmap(worker, &brush->u.pattern.pat);
     }
 }

@@ -3879,10 +4045,10 @@ static void unlocalize_brush(Brush *brush)
     }
 }

-static void localize_mask(RedWorker *worker, QMask *mask, long phys_delta)
+static void localize_mask(RedWorker *worker, QMask *mask)
 {
     if (mask->bitmap) {
-        localize_bitmap(worker, &mask->bitmap, phys_delta);
+        localize_bitmap(worker, &mask->bitmap);
     }
 }

@@ -3893,14 +4059,15 @@ static void unlocalize_mask(QMask *mask)
     }
 }

-static void localize_attr(LineAttr *attr, long phys_delta)
+static void localize_attr(RedWorker *worker, LineAttr *attr)
 {
     if (attr->style_nseg) {
         uint8_t *buf;
         uint8_t *data;

         ASSERT(attr->style);
-        buf = (uint8_t *)(attr->style + phys_delta);
+        check_mul_overflow(attr->style_nseg, sizeof(uint32_t));
+        buf = (uint8_t *)get_virt(worker, attr->style, attr->style_nseg * sizeof(uint32_t));
         data = malloc(attr->style_nseg * sizeof(uint32_t));
         ASSERT(data);
         memcpy(data, buf, attr->style_nseg * sizeof(uint32_t));
@@ -3923,16 +4090,12 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     worker->local_images_pos = 0;
     image_cache_eaging(&worker->image_cache);

-    worker->draw_context.set_access_params(worker->draw_context.canvas,
-                                           worker->dev_info.phys_delta);    // todo: use delta
-                                                                            //       instead of
-                                                                            //       localize_x
-    localize_clip(&clip, worker->dev_info.phys_delta);
+    localize_clip(worker, &clip);
     switch (drawable->type) {
     case QXL_DRAW_FILL: {
         Fill fill = drawable->u.fill;
-        localize_brush(worker, &fill.brush, worker->dev_info.phys_delta);
-        localize_mask(worker, &fill.mask, worker->dev_info.phys_delta);
+        localize_brush(worker, &fill.brush);
+        localize_mask(worker, &fill.mask);
         worker->draw_context.draw_fill(worker->draw_context.canvas, &drawable->bbox, &clip, &fill);
         unlocalize_mask(&fill.mask);
         unlocalize_brush(&fill.brush);
@@ -3940,9 +4103,9 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_OPAQUE: {
         Opaque opaque = drawable->u.opaque;
-        localize_brush(worker, &opaque.brush, worker->dev_info.phys_delta);
-        localize_bitmap(worker, &opaque.src_bitmap, worker->dev_info.phys_delta);
-        localize_mask(worker, &opaque.mask, worker->dev_info.phys_delta);
+        localize_brush(worker, &opaque.brush);
+        localize_bitmap(worker, &opaque.src_bitmap);
+        localize_mask(worker, &opaque.mask);
         worker->draw_context.draw_opaque(worker->draw_context.canvas, &drawable->bbox, &clip,
                                          &opaque);
         unlocalize_mask(&opaque.mask);
@@ -3952,8 +4115,8 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_COPY: {
         Copy copy = drawable->u.copy;
-        localize_bitmap(worker, &copy.src_bitmap, worker->dev_info.phys_delta);
-        localize_mask(worker, &copy.mask, worker->dev_info.phys_delta);
+        localize_bitmap(worker, &copy.src_bitmap);
+        localize_mask(worker, &copy.mask);
         worker->draw_context.draw_copy(worker->draw_context.canvas, &drawable->bbox, &clip, &copy);
         unlocalize_mask(&copy.mask);
         unlocalize_bitmap(&copy.src_bitmap);
@@ -3961,7 +4124,7 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_TRANSPARENT: {
         Transparent transparent = drawable->u.transparent;
-        localize_bitmap(worker, &transparent.src_bitmap, worker->dev_info.phys_delta);
+        localize_bitmap(worker, &transparent.src_bitmap);
         worker->draw_context.draw_transparent(worker->draw_context.canvas, &drawable->bbox, &clip,
                                               &transparent);
         unlocalize_bitmap(&transparent.src_bitmap);
@@ -3969,7 +4132,7 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_ALPHA_BLEND: {
         AlphaBlnd alpha_blend = drawable->u.alpha_blend;
-        localize_bitmap(worker, &alpha_blend.src_bitmap, worker->dev_info.phys_delta);
+        localize_bitmap(worker, &alpha_blend.src_bitmap);
         worker->draw_context.draw_alpha_blend(worker->draw_context.canvas, &drawable->bbox, &clip,
                                               &alpha_blend);
         unlocalize_bitmap(&alpha_blend.src_bitmap);
@@ -3982,8 +4145,8 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_BLEND: {
         Blend blend = drawable->u.blend;
-        localize_bitmap(worker, &blend.src_bitmap, worker->dev_info.phys_delta);
-        localize_mask(worker, &blend.mask, worker->dev_info.phys_delta);
+        localize_bitmap(worker, &blend.src_bitmap);
+        localize_mask(worker, &blend.mask);
         worker->draw_context.draw_blend(worker->draw_context.canvas, &drawable->bbox, &clip,
                                         &blend);
         unlocalize_mask(&blend.mask);
@@ -3992,7 +4155,7 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_BLACKNESS: {
         Blackness blackness = drawable->u.blackness;
-        localize_mask(worker, &blackness.mask, worker->dev_info.phys_delta);
+        localize_mask(worker, &blackness.mask);
         worker->draw_context.draw_blackness(worker->draw_context.canvas, &drawable->bbox, &clip,
                                             &blackness);
         unlocalize_mask(&blackness.mask);
@@ -4000,7 +4163,7 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_WHITENESS: {
         Whiteness whiteness = drawable->u.whiteness;
-        localize_mask(worker, &whiteness.mask, worker->dev_info.phys_delta);
+        localize_mask(worker, &whiteness.mask);
         worker->draw_context.draw_whiteness(worker->draw_context.canvas, &drawable->bbox, &clip,
                                             &whiteness);
         unlocalize_mask(&whiteness.mask);
@@ -4008,7 +4171,7 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_INVERS: {
         Invers invers = drawable->u.invers;
-        localize_mask(worker, &invers.mask, worker->dev_info.phys_delta);
+        localize_mask(worker, &invers.mask);
         worker->draw_context.draw_invers(worker->draw_context.canvas, &drawable->bbox, &clip,
                                          &invers);
         unlocalize_mask(&invers.mask);
@@ -4016,9 +4179,9 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_ROP3: {
         Rop3 rop3 = drawable->u.rop3;
-        localize_brush(worker, &rop3.brush, worker->dev_info.phys_delta);
-        localize_bitmap(worker, &rop3.src_bitmap, worker->dev_info.phys_delta);
-        localize_mask(worker, &rop3.mask, worker->dev_info.phys_delta);
+        localize_brush(worker, &rop3.brush);
+        localize_bitmap(worker, &rop3.src_bitmap);
+        localize_mask(worker, &rop3.mask);
         worker->draw_context.draw_rop3(worker->draw_context.canvas, &drawable->bbox, &clip, &rop3);
         unlocalize_mask(&rop3.mask);
         unlocalize_bitmap(&rop3.src_bitmap);
@@ -4027,9 +4190,9 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_STROKE: {
         Stroke stroke = drawable->u.stroke;
-        localize_brush(worker, &stroke.brush, worker->dev_info.phys_delta);
-        localize_path(&stroke.path, worker->dev_info.phys_delta);
-        localize_attr(&stroke.attr, worker->dev_info.phys_delta);
+        localize_brush(worker, &stroke.brush);
+        localize_path(worker, &stroke.path);
+        localize_attr(worker, &stroke.attr);
         worker->draw_context.draw_stroke(worker->draw_context.canvas, &drawable->bbox, &clip,
                                          &stroke);
         unlocalize_attr(&stroke.attr);
@@ -4039,9 +4202,9 @@ static void red_draw_qxl_drawable(RedWorker *worker, QXLDrawable *drawable)
     }
     case QXL_DRAW_TEXT: {
         Text text = drawable->u.text;
-        localize_brush(worker, &text.fore_brush, worker->dev_info.phys_delta);
-        localize_brush(worker, &text.back_brush, worker->dev_info.phys_delta);
-        localize_str(&text.str, worker->dev_info.phys_delta);
+        localize_brush(worker, &text.fore_brush);
+        localize_brush(worker, &text.back_brush);
+        localize_str(worker, &text.str);
         worker->draw_context.draw_text(worker->draw_context.canvas, &drawable->bbox, &clip, &text);
         unlocalize_str(&text.str);
         unlocalize_brush(&text.back_brush);
@@ -4290,9 +4453,8 @@ static int red_process_cursor(RedWorker *worker, uint32_t max_pipe_size)
         worker->repoll_cursor_ring = 0;
         switch (cmd.type) {
         case QXL_CMD_CURSOR: {
-            QXLCursorCmd *cursor_cmd = (QXLCursorCmd *)(cmd.data + worker->dev_info.phys_delta);
-            ASSERT((uint64_t)cursor_cmd >= worker->dev_info.phys_start);
-            ASSERT((uint64_t)cursor_cmd + sizeof(QXLCursorCmd) <= worker->dev_info.phys_end);
+            QXLCursorCmd *cursor_cmd = (QXLCursorCmd *)get_virt(worker, cmd.data,
+                                                                sizeof(QXLCursorCmd));
             qxl_process_cursor(worker, cursor_cmd);
             break;
         }
@@ -4328,32 +4490,26 @@ static int red_process_commands(RedWorker *worker, uint32_t max_pipe_size)
         worker->repoll_cmd_ring = 0;
         switch (cmd.type) {
         case QXL_CMD_DRAW: {
-            QXLDrawable *drawable = (QXLDrawable *)(cmd.data + worker->dev_info.phys_delta);
-            ASSERT((uint64_t)drawable >= worker->dev_info.phys_start);
-            ASSERT((uint64_t)drawable + sizeof(QXLDrawable) <= worker->dev_info.phys_end);
+            QXLDrawable *drawable = (QXLDrawable *)get_virt(worker, cmd.data, sizeof(QXLDrawable));
             red_process_drawable(worker, drawable);
             break;
         }
         case QXL_CMD_UPDATE: {
-            QXLUpdateCmd *draw_cmd = (QXLUpdateCmd *)(cmd.data + worker->dev_info.phys_delta);
-            ASSERT((uint64_t)draw_cmd >= worker->dev_info.phys_start);
-            ASSERT((uint64_t)draw_cmd + sizeof(QXLUpdateCmd) <= worker->dev_info.phys_end);
+            QXLUpdateCmd *draw_cmd = (QXLUpdateCmd *)get_virt(worker, cmd.data,
+                                                              sizeof(QXLUpdateCmd));
             red_update_area(worker, &draw_cmd->area);
             worker->qxl->notify_update(worker->qxl, draw_cmd->update_id);
             worker->qxl->release_resource(worker->qxl, &draw_cmd->release_info);
             break;
         }
         case QXL_CMD_CURSOR: {
-            QXLCursorCmd *cursor_cmd = (QXLCursorCmd *)(cmd.data + worker->dev_info.phys_delta);
-            ASSERT((uint64_t)cursor_cmd >= worker->dev_info.phys_start);
-            ASSERT((uint64_t)cursor_cmd + sizeof(QXLCursorCmd) <= worker->dev_info.phys_end);
+            QXLCursorCmd *cursor_cmd = (QXLCursorCmd *)get_virt(worker, cmd.data,
+                                                                sizeof(QXLCursorCmd));
             qxl_process_cursor(worker, cursor_cmd);
             break;
         }
         case QXL_CMD_MESSAGE: {
-            QXLMessage *message = (QXLMessage *)(cmd.data + worker->dev_info.phys_delta);
-            ASSERT((uint64_t)message >= worker->dev_info.phys_start);
-            ASSERT((uint64_t)message + sizeof(QXLDrawable) <= worker->dev_info.phys_end);
+            QXLMessage *message = (QXLMessage *)get_virt(worker, cmd.data, sizeof(QXLMessage));
             red_printf("MESSAGE: %s", message->data);
             worker->qxl->release_resource(worker->qxl, &message->release_info);
             break;
@@ -4415,6 +4571,7 @@ static void red_add_screen_image(RedWorker *worker)
         //warn
         return;
     }
+    red_trusted_host_virts_add(worker, (unsigned long)item, sizeof(ImageItem) + worker->dev_info.y_res * stride);

     red_pipe_item_init(&item->link, PIPE_ITEM_TYPE_IMAGE);

@@ -4430,7 +4587,7 @@ static void red_add_screen_image(RedWorker *worker)
     area.bottom = worker->dev_info.y_res;
     worker->draw_context.read_pixels(worker->draw_context.canvas, item->data, stride, &area);
     red_pipe_add_image_item(worker, item);
-    release_image_item(item);
+    release_image_item(worker, item);
     display_channel_push(worker);
 }

@@ -4451,9 +4608,11 @@ static void add_buf(RedChannel *channel, uint32_t type, void *data, uint32_t siz

 static void fill_path(DisplayChannel *display_channel, PHYSICAL *in_path)
 {
+    RedWorker *worker;
     RedChannel *channel = &display_channel->base;
+    worker = channel->worker;
     ASSERT(in_path && *in_path);
-    QXLPath *path = (QXLPath *)(*in_path + channel->worker->dev_info.phys_delta);
+    QXLPath *path = (QXLPath *)get_virt(worker, *in_path, sizeof(QXLPath));
     *in_path = channel->send_data.header.size;
     add_buf(channel, BUF_TYPE_RAW, &path->data_size, sizeof(UINT32));
     add_buf(channel, BUF_TYPE_CHUNK, &path->chunk, path->data_size);
@@ -4461,9 +4620,11 @@ static void fill_path(DisplayChannel *display_channel, PHYSICAL *in_path)

 static void fill_str(DisplayChannel *display_channel, PHYSICAL *in_str)
 {
+    RedWorker *worker;
     RedChannel *channel = &display_channel->base;
+    worker = channel->worker;
     ASSERT(in_str && *in_str);
-    QXLString *str = (QXLString *)(*in_str + channel->worker->dev_info.phys_delta);
+    QXLString *str = (QXLString *)get_virt(worker, *in_str, sizeof(QXLString));
     *in_str = channel->send_data.header.size;
     add_buf(channel, BUF_TYPE_RAW, &str->length, sizeof(UINT32));
     add_buf(channel, BUF_TYPE_CHUNK, &str->chunk, str->data_size);
@@ -4471,10 +4632,11 @@ static void fill_str(DisplayChannel *display_channel, PHYSICAL *in_str)

 static inline void fill_rects_clip(RedChannel *channel, PHYSICAL *in_clip)
 {
+    RedWorker *worker = channel->worker;
     QXLClipRects *clip;

     ASSERT(in_clip && *in_clip);
-    clip = (QXLClipRects *)(*in_clip + channel->worker->dev_info.phys_delta);
+    clip = (QXLClipRects *)get_virt(worker, *in_clip, sizeof(QXLClipRects));
     *in_clip = channel->send_data.header.size;
     add_buf(channel, BUF_TYPE_RAW, &clip->num_rects, sizeof(UINT32));
     add_buf(channel, BUF_TYPE_CHUNK, &clip->chunk, clip->num_rects * sizeof(Rect));
@@ -4505,12 +4667,13 @@ static inline RedImage *alloc_image(DisplayChannel *display_channel)
 static inline void fill_palette(DisplayChannel *display_channel, ADDRESS *io_palette, UINT8 *flags)
 {
     RedChannel *channel = &display_channel->base;
+    RedWorker *worker = channel->worker;
     Palette *palette;

     if (!(*io_palette)) {
         return;
     }
-    palette = (Palette *)(*io_palette + channel->worker->dev_info.phys_delta);
+    palette = (Palette *)get_virt(worker, *io_palette, sizeof(Palette));
     if (palette->unique) {
         if (red_palette_cache_find(display_channel, palette->unique)) {
             *flags |= BITMAP_PAL_FROM_CACHE;
@@ -4904,18 +5067,30 @@ static int glz_usr_more_space(GlzEncoderUsrContext *usr, uint8_t **io_ptr)

 static inline int encoder_usr_more_lines(EncoderData *enc_data, uint8_t **lines)
 {
+    uint32_t data_size;
+    uint8_t *data;
+
     if (!enc_data->u.lines_data.next) {
         return 0;
     }

-    QXLDataChunk *chunk = (QXLDataChunk *)(enc_data->u.lines_data.next +
-                                           enc_data->u.lines_data.address_delta);
-    if (chunk->data_size % enc_data->u.lines_data.stride) {
+    QXLDataChunk *chunk = (QXLDataChunk *)enc_data->u.lines_data.enc_get_virt(
+                          enc_data->u.lines_data.enc_get_virt_opaque, enc_data->u.lines_data.next,
+                          sizeof(QXLDataChunk));
+
+    data_size = chunk->data_size;
+    data = chunk->data;
+
+    if (data_size % enc_data->u.lines_data.stride) {
         return 0;
     }
+
+    enc_data->u.lines_data.enc_validate_virt(enc_data->u.lines_data.enc_validate_virt_opaque,
+                                             (unsigned long)data, data_size);
+
     enc_data->u.lines_data.next = chunk->next_chunk;
-    *lines = chunk->data;
-    return chunk->data_size / enc_data->u.lines_data.stride;
+    *lines = data;
+    return data_size / enc_data->u.lines_data.stride;
 }

 static int quic_usr_more_lines(QuicUsrContext *usr, uint8_t **lines)
@@ -4938,20 +5113,32 @@ static int glz_usr_more_lines(GlzEncoderUsrContext *usr, uint8_t **lines)

 static int quic_usr_more_lines_revers(QuicUsrContext *usr, uint8_t **lines)
 {
+    uint8_t *data;
+    uint32_t data_size;
     EncoderData *quic_data = &(((QuicData *)usr)->data);

     if (!quic_data->u.lines_data.next) {
         return 0;
     }

-    QXLDataChunk *chunk = (QXLDataChunk *)(quic_data->u.lines_data.next +
-                                           quic_data->u.lines_data.address_delta);
-    if (chunk->data_size % quic_data->u.lines_data.stride) {
+    QXLDataChunk *chunk = (QXLDataChunk *)quic_data->u.lines_data.enc_get_virt(
+                          quic_data->u.lines_data.enc_get_virt_opaque,
+                          quic_data->u.lines_data.next,
+                          sizeof(QXLDataChunk));
+
+    data_size = chunk->data_size;
+    data = chunk->data;
+
+    if (data_size % quic_data->u.lines_data.stride) {
         return 0;
     }
+
+    quic_data->u.lines_data.enc_validate_virt(quic_data->u.lines_data.enc_validate_virt_opaque,
+                                              (unsigned long)data, data_size);
+
     quic_data->u.lines_data.next = chunk->prev_chunk;
-    *lines = chunk->data + chunk->data_size - quic_data->u.lines_data.stride;
-    return chunk->data_size / quic_data->u.lines_data.stride;
+    *lines = data + data_size - quic_data->u.lines_data.stride;
+    return data_size / quic_data->u.lines_data.stride;
 }

 static int quic_usr_more_lines_unstable(QuicUsrContext *usr, uint8_t **out_lines)
@@ -5104,26 +5291,45 @@ typedef uint16_t rgb16_pixel_t;
 // assumes that stride doesn't overflow
 static BitmapGradualType _get_bitmap_graduality_level(RedWorker *worker, Bitmap *bitmap)
 {
-    long address_delta = worker->dev_info.phys_delta;
     double score = 0.0;
     int num_samples = 0;

     if ((bitmap->flags & QXL_BITMAP_DIRECT)) {
-        uint8_t *lines = (uint8_t*)(bitmap->data + address_delta);
+        uint32_t x;
+        uint32_t y;
+        uint32_t temp;
+
+        x = bitmap->x;
+        y = bitmap->y;
         switch (bitmap->format) {
-        case BITMAP_FMT_16BIT:
-            compute_lines_gradual_score_rgb16((rgb16_pixel_t*)lines, bitmap->x, bitmap->y,
-                                              &score, &num_samples);
+        case BITMAP_FMT_16BIT: {
+            uint8_t *lines = (uint8_t*)get_virt(worker, bitmap->data, x * y *
+                                                sizeof(rgb16_pixel_t));
+            check_mul_overflow(x, y);
+            temp = x * y;
+            check_mul_overflow(temp, sizeof(rgb16_pixel_t));
+            compute_lines_gradual_score_rgb16((rgb16_pixel_t*)lines, x, y, &score, &num_samples);
             break;
-        case BITMAP_FMT_24BIT:
-            compute_lines_gradual_score_rgb24((rgb24_pixel_t*)lines, bitmap->x, bitmap->y,
-                                              &score, &num_samples);
+        }
+        case BITMAP_FMT_24BIT: { 
+            uint8_t *lines = (uint8_t*)get_virt(worker, bitmap->data, x * y *
+                                                sizeof(rgb24_pixel_t));
+            check_mul_overflow(x, y);
+            temp = x * y;
+            check_mul_overflow(temp, sizeof(rgb24_pixel_t));
+            compute_lines_gradual_score_rgb24((rgb24_pixel_t*)lines, x, y, &score, &num_samples);
             break;
+        }
         case BITMAP_FMT_32BIT:
-        case BITMAP_FMT_RGBA:
-            compute_lines_gradual_score_rgb32((rgb32_pixel_t*)lines, bitmap->x, bitmap->y,
-                                              &score, &num_samples);
+        case BITMAP_FMT_RGBA: {
+            uint8_t *lines = (uint8_t*)get_virt(worker, bitmap->data, x * y *
+                                                sizeof(rgb32_pixel_t));
+            check_mul_overflow(x, y);
+            temp = x * y;
+            check_mul_overflow(temp, sizeof(rgb32_pixel_t));
+            compute_lines_gradual_score_rgb32((rgb32_pixel_t*)lines, x, y, &score, &num_samples);
             break;
+        }
         default:
             red_error("invalid bitmap format (not RGB) %u", bitmap->format);
         }
@@ -5132,23 +5338,41 @@ static BitmapGradualType _get_bitmap_graduality_level(RedWorker *worker, Bitmap
         int num_lines;
         double chunk_score = 0.0;
         int chunk_num_samples = 0;
+        uint32_t x;
+        uint32_t temp;
         ADDRESS relative_address = bitmap->data;

         while (relative_address) {
-            chunk = (QXLDataChunk *)(relative_address + address_delta);
+            chunk = (QXLDataChunk *)get_virt(worker, relative_address, sizeof(QXLDataChunk));
             num_lines = chunk->data_size / bitmap->stride;
+            x = bitmap->x;
             switch (bitmap->format) {
             case BITMAP_FMT_16BIT:
-                compute_lines_gradual_score_rgb16((rgb16_pixel_t*)chunk->data, bitmap->x, num_lines,
-                                                  &chunk_score, &chunk_num_samples);
+                check_mul_overflow(sizeof(rgb16_pixel_t), x);
+                temp = sizeof(rgb16_pixel_t) * x;
+                check_mul_overflow(temp, num_lines);
+                validate_virt(worker, (unsigned long)chunk->data,
+                              sizeof(rgb16_pixel_t) * x * num_lines);
+                compute_lines_gradual_score_rgb16((rgb16_pixel_t*)chunk->data, x, num_lines,
+                                                   &chunk_score, &chunk_num_samples);
                 break;
             case BITMAP_FMT_24BIT:
-                compute_lines_gradual_score_rgb24((rgb24_pixel_t*)chunk->data, bitmap->x, num_lines,
-                                                  &chunk_score, &chunk_num_samples);
+                check_mul_overflow(sizeof(rgb24_pixel_t), x);
+                temp = sizeof(rgb24_pixel_t) * x;
+                check_mul_overflow(temp, num_lines);
+                validate_virt(worker, (unsigned long)chunk->data,
+                              sizeof(rgb24_pixel_t) * x * num_lines);
+                compute_lines_gradual_score_rgb24((rgb24_pixel_t*)chunk->data, x, num_lines,
+                                                   &chunk_score, &chunk_num_samples);
                 break;
             case BITMAP_FMT_32BIT:
             case BITMAP_FMT_RGBA:
-                compute_lines_gradual_score_rgb32((rgb32_pixel_t*)chunk->data, bitmap->x, num_lines,
+                check_mul_overflow(sizeof(rgb32_pixel_t), x);
+                temp = sizeof(rgb32_pixel_t) * x;
+                check_mul_overflow(temp, num_lines);
+                validate_virt(worker, (unsigned long)chunk->data,
+                              sizeof(rgb32_pixel_t) *  x * num_lines);
+                compute_lines_gradual_score_rgb32((rgb32_pixel_t*)chunk->data, x, num_lines,
                                                   &chunk_score, &chunk_num_samples);
                 break;
             default:
@@ -5185,7 +5409,7 @@ static BitmapGradualType _get_bitmap_graduality_level(RedWorker *worker, Bitmap
 static inline int _stride_is_extra(Bitmap *bitmap)
 {
     ASSERT(bitmap);
-    if (BITMAP_FMT_IS_RGB[bitmap->format]) {
+    if (BITMAP_FMT_IS_RGB[MIN(bitmap->format, sizeof(BITMAP_FMT_IS_RGB) / sizeof(int))]) {
         return ((bitmap->x * BITMAP_FMP_BYTES_PER_PIXEL[bitmap->format]) < bitmap->stride);
     } else {
         switch (bitmap->format) {
@@ -5233,18 +5457,25 @@ static inline int red_glz_compress_image(DisplayChannel *display_channel,
                                          RedImage *dest, Bitmap *src, Drawable *drawable,
                                          compress_send_data_t* o_comp_data)
 {
+    RedWorker *worker = (RedWorker *)display_channel->base.worker;
 #ifdef COMPRESS_STAT
     stat_time_t start_time = stat_now();
 #endif
-    ASSERT(BITMAP_FMT_IS_RGB[src->format]);
+    ASSERT(BITMAP_FMT_IS_RGB[MIN(src->format, sizeof(BITMAP_FMT_IS_RGB) / sizeof(int))]);
     GlzData *glz_data = &display_channel->glz_data;
-    LzImageType type = MAP_BITMAP_FMT_TO_LZ_IMAGE_TYPE[src->format];
+    LzImageType type = MAP_BITMAP_FMT_TO_LZ_IMAGE_TYPE[MIN(src->format,
+                                                          sizeof(MAP_BITMAP_FMT_TO_LZ_IMAGE_TYPE) /
+                                                          sizeof(LzImageType))];
     RedGlzDrawable *glz_drawable;
     GlzDrawableInstanceItem *glz_drawable_instance;
+    uint32_t src_stride;
+    uint32_t src_y;
     uint8_t *lines;
     unsigned int num_lines;
     int size;
-    long address_delta;
+
+    src_stride = src->stride;
+    src_y = src->y;

     glz_data->data.bufs_tail = red_display_alloc_compress_buf(display_channel);
     glz_data->data.bufs_head = glz_data->data.bufs_tail;
@@ -5255,27 +5486,30 @@ static inline int red_glz_compress_image(DisplayChannel *display_channel,

     glz_data->data.bufs_head->send_next = NULL;
     glz_data->data.display_channel = display_channel;
-    address_delta = display_channel->base.worker->dev_info.phys_delta;

     glz_drawable = red_display_get_glz_drawable(display_channel, drawable);
     glz_drawable_instance = red_display_add_glz_drawable_instance(glz_drawable);

     if ((src->flags & QXL_BITMAP_DIRECT)) {
         glz_data->usr.more_lines = glz_usr_no_more_lines;
-        lines = (uint8_t*)(src->data + address_delta);
-        num_lines = src->y;
+        check_mul_overflow(src_stride, src_y);
+        lines = (uint8_t*)get_virt(worker, src->data, src_stride * src_y);
+        num_lines = src_y;
     } else {
-        glz_data->data.u.lines_data.address_delta = address_delta;
-        glz_data->data.u.lines_data.stride = src->stride;
+        glz_data->data.u.lines_data.enc_get_virt = cb_get_virt;
+        glz_data->data.u.lines_data.enc_get_virt_opaque = worker;
+        glz_data->data.u.lines_data.enc_validate_virt = cb_validate_virt;
+        glz_data->data.u.lines_data.enc_validate_virt_opaque = worker;
+        glz_data->data.u.lines_data.stride = src_stride;
         glz_data->data.u.lines_data.next = src->data;
         glz_data->usr.more_lines = glz_usr_more_lines;
         lines = NULL;
         num_lines = 0;
     }

-    size = glz_encode(display_channel->glz, type, src->x, src->y,
+    size = glz_encode(display_channel->glz, type, src->x, src_y,
                       (src->flags & QXL_BITMAP_TOP_DOWN), lines, num_lines,
-                      src->stride, (uint8_t*)glz_data->data.bufs_head->buf,
+                      src_stride, (uint8_t*)glz_data->data.bufs_head->buf,
                       sizeof(glz_data->data.bufs_head->buf),
                       glz_drawable_instance,
                       &glz_drawable_instance->glz_instance);
@@ -5289,7 +5523,7 @@ static inline int red_glz_compress_image(DisplayChannel *display_channel,
     o_comp_data->plt_ptr = NULL;
     o_comp_data->flags_ptr = NULL;

-    stat_compress_add(&display_channel->glz_stat, start_time, src->stride * src->y,
+    stat_compress_add(&display_channel->glz_stat, start_time, src_stride * src_y,
                       o_comp_data->comp_buf_size);
     return TRUE;
 }
@@ -5301,14 +5535,20 @@ static inline int red_lz_compress_image(DisplayChannel *display_channel,
     RedWorker *worker = display_channel->base.worker;
     LzData *lz_data = &worker->lz_data;
     LzContext *lz = worker->lz;
-    LzImageType type = MAP_BITMAP_FMT_TO_LZ_IMAGE_TYPE[src->format];
-    long address_delta;
+    LzImageType type = MAP_BITMAP_FMT_TO_LZ_IMAGE_TYPE[MIN(src->format,
+                                                          sizeof(MAP_BITMAP_FMT_TO_LZ_IMAGE_TYPE) /
+                                                          sizeof(LzImageType))];
+    uint32_t src_y;
+    uint32_t src_stride;
     int size;            // size of the compressed data

 #ifdef COMPRESS_STAT
     stat_time_t start_time = stat_now();
 #endif

+    src_y = src->y;
+    src_stride = src->stride;
+
     lz_data->data.bufs_tail = red_display_alloc_compress_buf(display_channel);
     lz_data->data.bufs_head = lz_data->data.bufs_tail;

@@ -5318,7 +5558,6 @@ static inline int red_lz_compress_image(DisplayChannel *display_channel,

     lz_data->data.bufs_head->send_next = NULL;
     lz_data->data.display_channel = display_channel;
-    address_delta = worker->dev_info.phys_delta;

     if (setjmp(lz_data->data.jmp_env)) {
         while (lz_data->data.bufs_head) {
@@ -5331,28 +5570,32 @@ static inline int red_lz_compress_image(DisplayChannel *display_channel,

     if ((src->flags & QXL_BITMAP_DIRECT)) {
         lz_data->usr.more_lines = lz_usr_no_more_lines;
-        size = lz_encode(lz, type, src->x, src->y, (src->flags & QXL_BITMAP_TOP_DOWN),
-                         (uint8_t*)(src->data + address_delta), src->y, src->stride,
-                         (uint8_t*)lz_data->data.bufs_head->buf,
+        check_mul_overflow(src_stride, src_y);
+        size = lz_encode(lz, type, src->x, src_y, (src->flags & QXL_BITMAP_TOP_DOWN),
+                        (uint8_t*)get_virt(worker, src->data, src_stride * src_y), src_y,
+                         src->stride, (uint8_t*)lz_data->data.bufs_head->buf,
                          sizeof(lz_data->data.bufs_head->buf));
     } else {
-        lz_data->data.u.lines_data.address_delta = address_delta;
-        lz_data->data.u.lines_data.stride = src->stride;
+        lz_data->data.u.lines_data.enc_get_virt = cb_get_virt;
+        lz_data->data.u.lines_data.enc_get_virt_opaque = worker;
+        lz_data->data.u.lines_data.enc_validate_virt = cb_validate_virt;
+        lz_data->data.u.lines_data.enc_validate_virt_opaque = worker;
+        lz_data->data.u.lines_data.stride = src_stride;
         lz_data->data.u.lines_data.next = src->data;
         lz_data->usr.more_lines = lz_usr_more_lines;

-        size = lz_encode(lz, type, src->x, src->y, (src->flags & QXL_BITMAP_TOP_DOWN),
-                         NULL, 0, src->stride,
+        size = lz_encode(lz, type, src->x, src_y, (src->flags & QXL_BITMAP_TOP_DOWN),
+                         NULL, 0, src_stride,
                          (uint8_t*)lz_data->data.bufs_head->buf,
                          sizeof(lz_data->data.bufs_head->buf));
     }

     // the compressed buffer is bigger than the original data
-    if (size > (src->y * src->stride)) {
+    if (size > (src_y * src_stride)) {
         longjmp(lz_data->data.jmp_env, 1);
     }

-    if (BITMAP_FMT_IS_RGB[src->format]) {
+    if (BITMAP_FMT_IS_RGB[MIN(src->format, sizeof(BITMAP_FMT_IS_RGB) / sizeof(int))]) {
         dest->descriptor.type = IMAGE_TYPE_LZ_RGB;
         dest->lz_rgb.data_size = size;

@@ -5373,7 +5616,7 @@ static inline int red_lz_compress_image(DisplayChannel *display_channel,
         o_comp_data->plt_ptr = &(dest->lz_plt.palette);
         o_comp_data->flags_ptr = &(dest->lz_plt.flags);
     }
-    stat_compress_add(&display_channel->lz_stat, start_time, src->stride * src->y,
+    stat_compress_add(&display_channel->lz_stat, start_time, src_stride * src_y,
                       o_comp_data->comp_buf_size);
     return TRUE;
 }
@@ -5385,13 +5628,17 @@ static inline int red_quic_compress_image(DisplayChannel *display_channel, RedIm
     QuicData *quic_data = &worker->quic_data;
     QuicContext *quic = worker->quic;
     QuicImageType type;
-    long address_delta;
+    uint32_t src_y;
+    uint32_t src_stride;
     int size;

 #ifdef COMPRESS_STAT
     stat_time_t start_time = stat_now();
 #endif

+    src_y = src->y;
+    src_stride = src->stride;
+
     switch (src->format) {
     case BITMAP_FMT_32BIT:
         type = QUIC_IMAGE_TYPE_RGB32;
@@ -5418,7 +5665,6 @@ static inline int red_quic_compress_image(DisplayChannel *display_channel, RedIm

     quic_data->data.bufs_head->send_next = NULL;
     quic_data->data.display_channel = display_channel;
-    address_delta = worker->dev_info.phys_delta;

     if (setjmp(quic_data->data.jmp_env)) {
         while (quic_data->data.bufs_head) {
@@ -5434,18 +5680,21 @@ static inline int red_quic_compress_image(DisplayChannel *display_channel, RedIm
         uint8_t *data;

         if (!(src->flags & QXL_BITMAP_TOP_DOWN)) {
-            data = (uint8_t*)(src->data + address_delta) + src->stride * (src->y - 1);
-            stride = -src->stride;
+            check_mul_overflow(src_stride, src_y);
+            data = (uint8_t*)get_virt(worker, src->data, src_stride * src_y) +
+                             src_stride * (src_y - 1);
+            stride = -src_stride;
         } else {
-            data = (uint8_t*)(src->data + address_delta);
-            stride = src->stride;
+            check_mul_overflow(src_stride, src_y);
+            data = (uint8_t*)get_virt(worker, src->data, src_stride * src_y);
+            stride = src_stride;
         }

         if ((src->flags & QXL_BITMAP_UNSTABLE)) {
             quic_data->data.u.unstable_lines_data.next = data;
             quic_data->data.u.unstable_lines_data.src_stride = stride;
-            quic_data->data.u.unstable_lines_data.dest_stride = src->stride;
-            quic_data->data.u.unstable_lines_data.lines = src->y;
+            quic_data->data.u.unstable_lines_data.dest_stride = src_stride;
+            quic_data->data.u.unstable_lines_data.lines = src_y;
             quic_data->data.u.unstable_lines_data.input_bufs_pos = 0;
             if (!(quic_data->data.u.unstable_lines_data.input_bufs[0] =
                                             red_display_alloc_compress_buf(display_channel)) ||
@@ -5457,12 +5706,12 @@ static inline int red_quic_compress_image(DisplayChannel *display_channel, RedIm
                                  sizeof(quic_data->data.u.unstable_lines_data.input_bufs[0]->buf) /
                                  quic_data->data.u.unstable_lines_data.dest_stride;
             quic_data->usr.more_lines = quic_usr_more_lines_unstable;
-            size = quic_encode(quic, type, src->x, src->y, NULL, 0, src->stride,
+            size = quic_encode(quic, type, src->x, src_y, NULL, 0, src_stride,
                                quic_data->data.bufs_head->buf,
                                sizeof(quic_data->data.bufs_head->buf) >> 2);
         } else {
             quic_data->usr.more_lines = quic_usr_no_more_lines;
-            size = quic_encode(quic, type, src->x, src->y, data, src->y, stride,
+            size = quic_encode(quic, type, src->x, src_y, data, src_y, stride,
                                quic_data->data.bufs_head->buf,
                                sizeof(quic_data->data.bufs_head->buf) >> 2);
         }
@@ -5473,30 +5722,33 @@ static inline int red_quic_compress_image(DisplayChannel *display_channel, RedIm
             red_printf_once("unexpected unstable bitmap");
             return FALSE;
         }
-        quic_data->data.u.lines_data.address_delta = address_delta;
-        quic_data->data.u.lines_data.stride = src->stride;
+        quic_data->data.u.lines_data.enc_get_virt = cb_get_virt;
+        quic_data->data.u.lines_data.enc_get_virt_opaque = worker;
+        quic_data->data.u.lines_data.enc_validate_virt = cb_validate_virt;
+        quic_data->data.u.lines_data.enc_validate_virt_opaque = worker;
+        quic_data->data.u.lines_data.stride = src_stride;

         if ((src->flags & QXL_BITMAP_TOP_DOWN)) {
             quic_data->data.u.lines_data.next = src->data;
             quic_data->usr.more_lines = quic_usr_more_lines;
-            stride = src->stride;
+            stride = src_stride;
         } else {
-            QXLDataChunk *chunk = (QXLDataChunk *)(src->data + address_delta);
+            QXLDataChunk *chunk = (QXLDataChunk *)get_virt(worker, src->data, sizeof(QXLDataChunk));
             while (chunk->next_chunk) {
-                chunk = (QXLDataChunk *)(chunk->next_chunk + address_delta);
+                chunk = (QXLDataChunk *)get_virt(worker, chunk->next_chunk, sizeof(QXLDataChunk));
                 ASSERT(chunk->prev_chunk);
             }
-            quic_data->data.u.lines_data.next = (ADDRESS)chunk - address_delta;
+            quic_data->data.u.lines_data.next = (ADDRESS)chunk -get_virt_delta(worker);
             quic_data->usr.more_lines = quic_usr_more_lines_revers;
-            stride = -src->stride;
+            stride = -src_stride;
         }
-        size = quic_encode(quic, type, src->x, src->y, NULL, 0, stride,
+        size = quic_encode(quic, type, src->x, src_y, NULL, 0, stride,
                            quic_data->data.bufs_head->buf,
                            sizeof(quic_data->data.bufs_head->buf) >> 2);
     }

     // the compressed buffer is bigger than the original data
-    if ((size << 2) > (src->y * src->stride)) {
+    if ((size << 2) > (src_y * src_stride)) {
         longjmp(quic_data->data.jmp_env, 1);
     }

@@ -5509,7 +5761,7 @@ static inline int red_quic_compress_image(DisplayChannel *display_channel, RedIm
     o_comp_data->plt_ptr = NULL;
     o_comp_data->flags_ptr = NULL;

-    stat_compress_add(&display_channel->quic_stat, start_time, src->stride * src->y,
+    stat_compress_add(&display_channel->quic_stat, start_time, src_stride * src_y,
                       o_comp_data->comp_buf_size);
     return TRUE;
 }
@@ -5528,7 +5780,7 @@ static inline int red_compress_image(DisplayChannel *display_channel,
         ((src->y * src->stride) < MIN_SIZE_TO_COMPRESS)) { // TODO: change the size cond
         return FALSE;
     } else if (image_compression == SPICE_IMAGE_COMPRESS_QUIC) {
-        if (BITMAP_FMT_IS_PLT[src->format]) {
+        if (BITMAP_FMT_IS_PLT[MIN(src->format, sizeof(BITMAP_FMT_IS_PLT) / sizeof(int))]) {
             return FALSE;
         } else {
             quic_compress = TRUE;
@@ -5541,7 +5793,7 @@ static inline int red_compress_image(DisplayChannel *display_channel,
         if (_stride_is_extra(src) || (src->flags & QXL_BITMAP_UNSTABLE)) {
             if ((image_compression == SPICE_IMAGE_COMPRESS_LZ) ||
                 (image_compression == SPICE_IMAGE_COMPRESS_GLZ) ||
-                BITMAP_FMT_IS_PLT[src->format]) {
+                BITMAP_FMT_IS_PLT[MIN(src->format, sizeof(BITMAP_FMT_IS_PLT)/ sizeof(int))]) {
                 return FALSE;
             } else {
                 quic_compress = TRUE;
@@ -5553,7 +5805,8 @@ static inline int red_compress_image(DisplayChannel *display_channel,
                     quic_compress = FALSE;
                 } else {
                     if (drawable->copy_bitmap_graduality == BITMAP_GRADUAL_INVALID) {
-                        quic_compress = BITMAP_FMT_IS_RGB[src->format] &&
+                        quic_compress = BITMAP_FMT_IS_RGB[MIN(src->format,
+                                                              sizeof(BITMAP_FMT_IS_RGB) / sizeof(int))] &&
                             (_get_bitmap_graduality_level(display_channel->base.worker, src) ==
                              BITMAP_GRADUAL_HIGH);
                     } else {
@@ -5576,7 +5829,7 @@ static inline int red_compress_image(DisplayChannel *display_channel,
         int ret;
         if ((image_compression == SPICE_IMAGE_COMPRESS_AUTO_GLZ) ||
             (image_compression == SPICE_IMAGE_COMPRESS_GLZ)) {
-            glz = BITMAP_FMT_IS_RGB[src->format] && (
+            glz = BITMAP_FMT_IS_RGB[MIN(src->format, sizeof(BITMAP_FMT_IS_RGB) / sizeof(int))] && (
                     (src->x * src->y) < glz_enc_dictionary_get_size(
                         display_channel->glz_dict->dict));
         } else if ((image_compression == SPICE_IMAGE_COMPRESS_AUTO_LZ) ||
@@ -5636,6 +5889,7 @@ static inline void red_display_add_image_to_pixmap_cache(DisplayChannel *display
 static void fill_bits(DisplayChannel *display_channel, PHYSICAL *in_bitmap, Drawable *drawable)
 {
     RedChannel *channel = &display_channel->base;
+    RedWorker *worker = channel->worker;
     RedImage *image;
     QXLImage *qxl_image;
     uint8_t *data;
@@ -5644,7 +5898,7 @@ static void fill_bits(DisplayChannel *display_channel, PHYSICAL *in_bitmap, Draw
     ASSERT(*in_bitmap);

     image = alloc_image(display_channel);
-    qxl_image = (QXLImage *)(*in_bitmap + channel->worker->dev_info.phys_delta);
+    qxl_image = (QXLImage *)get_virt(worker, *in_bitmap, sizeof(QXLImage));

     image->descriptor.id = qxl_image->descriptor.id;
     image->descriptor.type = qxl_image->descriptor.type;
@@ -5673,17 +5927,28 @@ static void fill_bits(DisplayChannel *display_channel, PHYSICAL *in_bitmap, Draw
            global dictionary (in cases of multiple monitors) */
         if (!red_compress_image(display_channel, image, &qxl_image->bitmap,
                                 drawable, &comp_send_data)) {
+            uint32_t y;
+            uint32_t stride;
+            ADDRESS image_data;
             red_display_add_image_to_pixmap_cache(display_channel, qxl_image, image);

             image->bitmap = qxl_image->bitmap;
+            y = image->bitmap.y;
+            stride = image->bitmap.stride;
+            image_data = image->bitmap.data;
             image->bitmap.flags = image->bitmap.flags & BITMAP_TOP_DOWN;
             add_buf(channel, BUF_TYPE_RAW, image, sizeof(BitmapImage));
             fill_palette(display_channel, &(image->bitmap.palette), &(image->bitmap.flags));
-            data = (uint8_t *)(image->bitmap.data + channel->worker->dev_info.phys_delta);
             image->bitmap.data = channel->send_data.header.size;
-            add_buf(channel,
-                    (qxl_image->bitmap.flags & QXL_BITMAP_DIRECT) ? BUF_TYPE_RAW : BUF_TYPE_CHUNK,
-                    data, image->bitmap.y * image->bitmap.stride);
+            if (qxl_image->bitmap.flags & QXL_BITMAP_DIRECT) {
+                check_mul_overflow(stride, y);
+                data = (uint8_t *)get_virt(worker, image_data, stride * y);
+                add_buf(channel, BUF_TYPE_RAW, data, y * stride);
+            } else {
+                check_mul_overflow(stride, y);
+                data = (uint8_t *)get_virt(worker, image_data, sizeof(QXLDataChunk));
+                add_buf(channel, BUF_TYPE_CHUNK, data, y * stride);
+            }
         } else {
             red_display_add_image_to_pixmap_cache(display_channel, qxl_image, image);

@@ -5733,7 +5998,9 @@ static void fill_attr(DisplayChannel *display_channel, LineAttr *attr)
 {
     if (attr->style_nseg) {
         RedChannel *channel = &display_channel->base;
-        uint8_t *buf = (uint8_t *)(attr->style + channel->worker->dev_info.phys_delta);
+        uint8_t *buf = (uint8_t *)get_virt(channel->worker, attr->style,
+                                           attr->style_nseg * sizeof(uint32_t));
+        check_mul_overflow(attr->style_nseg, sizeof(uint32_t));
         ASSERT(attr->style);
         attr->style = channel->send_data.header.size;
         add_buf(channel, BUF_TYPE_RAW, buf, attr->style_nseg * sizeof(uint32_t));
@@ -5754,7 +6021,8 @@ static void fill_cursor(CursorChannel *cursor_channel, RedCursor *red_cursor, Cu
         QXLCursor *qxl_cursor;

         cursor_cmd = CONTAINEROF(cursor, QXLCursorCmd, device_data);
-        qxl_cursor = (QXLCursor *)(cursor_cmd->u.set.shape + channel->worker->dev_info.phys_delta);
+        qxl_cursor = (QXLCursor *)get_virt(channel->worker, cursor_cmd->u.set.shape,
+                                           sizeof(QXLCursor));
         red_cursor->flags = 0;
         red_cursor->header = qxl_cursor->header;

@@ -5930,8 +6198,8 @@ static inline BufDescriptor *find_buf(RedChannel *channel, int buf_pos, int *buf
     return buf;
 }

-static inline uint32_t __fill_iovec(BufDescriptor *buf, int skip, struct iovec *vec, int *vec_index,
-                                    long phys_delta)
+static inline uint32_t __fill_iovec(RedWorker *worker, BufDescriptor *buf, int skip,
+                                    struct iovec *vec, int *vec_index)
 {
     uint32_t size = 0;

@@ -5972,12 +6240,15 @@ static inline uint32_t __fill_iovec(BufDescriptor *buf, int skip, struct iovec *
             data_size -= skip_now;

             if (data_size) {
+                validate_virt(worker, (unsigned long)chunk->data, data_size);
                 size += data_size;
                 vec[*vec_index].iov_base = chunk->data + skip_now;
                 vec[*vec_index].iov_len = data_size;
                 (*vec_index)++;
             }
-            chunk = chunk->next_chunk ? (QXLDataChunk *)(chunk->next_chunk + phys_delta) : NULL;
+            chunk = chunk->next_chunk ?
+                   (QXLDataChunk *)get_virt(worker, chunk->next_chunk, sizeof(QXLDataChunk)) :
+                   NULL;
         } while (chunk && *vec_index < MAX_SEND_VEC);
         break;
     }
@@ -6000,7 +6271,7 @@ static inline void fill_iovec(RedChannel *channel, struct iovec *vec, int *vec_s

         buf = find_buf(channel, pos, &buf_offset);
         ASSERT(buf);
-        pos += __fill_iovec(buf, buf_offset, vec, &vec_index, channel->worker->dev_info.phys_delta);
+        pos += __fill_iovec(channel->worker, buf, buf_offset, vec, &vec_index);
     } while (vec_index < MAX_SEND_VEC && pos != channel->send_data.size);
     *vec_size = vec_index;
 }
@@ -6157,11 +6428,17 @@ static inline void red_unref_channel(RedChannel *channel)
     }
 }

-static inline uint8_t *red_get_image_line(QXLDataChunk **chunk, int *offset, int stride,
-                                          long phys_delta)
+static inline uint8_t *red_get_image_line(RedWorker *worker, QXLDataChunk **chunk, int *offset,
+                                          int stride, long phys_delta)
 {
     uint8_t *ret;
-    if ((*chunk)->data_size == *offset) {
+    uint32_t data_size;
+
+    validate_virt(worker, (unsigned long)*chunk, sizeof(QXLDataChunk));
+    data_size = (*chunk)->data_size;
+    validate_virt(worker, (unsigned long)(*chunk)->data, data_size);
+
+    if (data_size == *offset) {
         if ((*chunk)->next_chunk == 0) {
             return NULL;
         }
@@ -6169,7 +6446,11 @@ static inline uint8_t *red_get_image_line(QXLDataChunk **chunk, int *offset, int
         *chunk = (QXLDataChunk *)((*chunk)->next_chunk + phys_delta);
     }

-    if ((*chunk)->data_size - *offset < stride) {
+    validate_virt(worker, (unsigned long)*chunk, sizeof(QXLDataChunk));
+    data_size = (*chunk)->data_size;
+    validate_virt(worker, (unsigned long)(*chunk)->data, data_size);
+
+    if (data_size - *offset < stride) {
         red_printf("bad chunk aligment");
         return NULL;
     }
@@ -6211,8 +6492,8 @@ static inline int red_send_stream_data(DisplayChannel *display_channel, Drawable

     channel = &display_channel->base;
     worker = channel->worker;
-    qxl_image = (QXLImage *)(drawable->qxl_drawable->u.copy.src_bitmap +
-                             worker->dev_info.phys_delta);
+    qxl_image = (QXLImage *)get_virt(worker,  drawable->qxl_drawable->u.copy.src_bitmap,
+                                     sizeof(QXLImage));

     if (qxl_image->descriptor.type != IMAGE_TYPE_BITMAP ||
                                             (qxl_image->bitmap.flags & QXL_BITMAP_DIRECT)) {
@@ -6228,25 +6509,25 @@ static inline int red_send_stream_data(DisplayChannel *display_channel, Drawable

     switch (qxl_image->bitmap.format) {
     case BITMAP_FMT_32BIT:
-        if (!red_rgb_to_yuv420_32bpp(&drawable->qxl_drawable->u.copy.src_area,
+        if (!red_rgb_to_yuv420_32bpp(worker, &drawable->qxl_drawable->u.copy.src_area,
                                      &qxl_image->bitmap, stream->av_frame,
-                                     worker->dev_info.phys_delta,
+                                     get_virt_delta(worker),
                                      stream - worker->streams_buf, stream)) {
             return FALSE;
         }
         break;
     case BITMAP_FMT_16BIT:
-        if (!red_rgb_to_yuv420_16bpp(&drawable->qxl_drawable->u.copy.src_area,
+        if (!red_rgb_to_yuv420_16bpp(worker, &drawable->qxl_drawable->u.copy.src_area,
                                      &qxl_image->bitmap, stream->av_frame,
-                                     worker->dev_info.phys_delta,
+                                     get_virt_delta(worker),
                                      stream - worker->streams_buf, stream)) {
             return FALSE;
         }
         break;
     case BITMAP_FMT_24BIT:
-        if (!red_rgb_to_yuv420_24bpp(&drawable->qxl_drawable->u.copy.src_area,
+        if (!red_rgb_to_yuv420_24bpp(worker, &drawable->qxl_drawable->u.copy.src_area,
                                      &qxl_image->bitmap, stream->av_frame,
-                                     worker->dev_info.phys_delta,
+                                     get_virt_delta(worker),
                                      stream - worker->streams_buf, stream)) {
             return FALSE;
         }
@@ -6838,7 +7119,7 @@ static void display_channel_push(RedWorker *worker)
             break;
         case PIPE_ITEM_TYPE_IMAGE:
             red_send_image(display_channel, (ImageItem *)pipe_item);
-            release_image_item((ImageItem *)pipe_item);
+            release_image_item(worker, (ImageItem *)pipe_item);
             break;
         case PIPE_ITEM_TYPE_PIXMAP_SYNC:
             display_channel_pixmap_sync(display_channel);
@@ -7052,7 +7333,6 @@ static void init_cairo_draw_context(RedWorker *worker, CairoCanvas *canvas)
 {
     worker->draw_context.canvas = canvas;
     worker->draw_context.top_down = TRUE;
-    worker->draw_context.set_access_params = (set_access_params_t)canvas_set_access_params;
     worker->draw_context.draw_fill = (draw_fill_t)canvas_draw_fill;
     worker->draw_context.draw_copy = (draw_copy_t)canvas_draw_copy;
     worker->draw_context.draw_opaque = (draw_opaque_t)canvas_draw_opaque;
@@ -7098,7 +7378,8 @@ static int create_cairo_context(RedWorker *worker)
     }

     if (!(canvas = canvas_create(cairo, worker->dev_info.bits, &worker->image_cache,
-                                 image_cache_put, image_cache_get))) {
+                                 image_cache_put, image_cache_get, worker, cb_get_virt,
+                                 worker, cb_validate_virt))) {
         red_error("create cairo canvas failed");
     }
     init_cairo_draw_context(worker, canvas);
@@ -7140,7 +7421,6 @@ static void init_ogl_draw_context(RedWorker *worker, GLCanvas *canvas)
 {
     worker->draw_context.canvas = canvas;
     worker->draw_context.top_down = FALSE;
-    worker->draw_context.set_access_params = (set_access_params_t)gl_canvas_set_access_params;
     worker->draw_context.draw_fill = (draw_fill_t)gl_canvas_draw_fill;
     worker->draw_context.draw_copy = (draw_copy_t)gl_canvas_draw_copy;
     worker->draw_context.draw_opaque = (draw_opaque_t)gl_canvas_draw_opaque;
@@ -7173,7 +7453,8 @@ static int create_ogl_context_common(RedWorker *worker, OGLCtx *ctx)

     oglctx_make_current(ctx);
     if (!(canvas = gl_canvas_create(ctx, width, height, worker->dev_info.bits, &worker->image_cache,
-                                    image_cache_put, image_cache_get))) {
+                                    image_cache_put, image_cache_get, worker, cb_get_virt,
+                                    worker, cb_validate_virt))) {
         return FALSE;
     }

@@ -7822,7 +8103,10 @@ static void display_channel_hold_item(void *item)

 static void display_channel_release_item(RedChannel *channel, void *item)
 {
+    RedWorker *worker;
     ASSERT(item);
+
+    worker = channel->worker;
     switch (((PipeItem *)item)->type) {
     case PIPE_ITEM_TYPE_DRAW:
     case PIPE_ITEM_TYPE_STREAM_CREATE:
@@ -7835,7 +8119,7 @@ static void display_channel_release_item(RedChannel *channel, void *item)
         release_upgrade_item(channel->worker, (UpgradeItem *)item);
         break;
     case PIPE_ITEM_TYPE_IMAGE:
-        release_image_item((ImageItem *)item);
+        release_image_item(worker, (ImageItem *)item);
         break;
     default:
         PANIC("invalid item type");
@@ -8037,7 +8321,7 @@ static void red_cursor_flush(RedWorker *worker)

     cursor_cmd = CONTAINEROF(worker->cursor, QXLCursorCmd, device_data);
     ASSERT(cursor_cmd->type == QXL_CURSOR_SET);
-    qxl_cursor = (QXLCursor *)(cursor_cmd->u.set.shape + worker->dev_info.phys_delta);
+    qxl_cursor = (QXLCursor *)get_virt(worker, cursor_cmd->u.set.shape, sizeof(QXLCursor));

     local = _new_local_cursor(&qxl_cursor->header, qxl_cursor->data_size,
                               worker->cursor_position);
@@ -8052,8 +8336,8 @@ static void red_cursor_flush(RedWorker *worker)
         memcpy(dest, chunk->data, chunk->data_size);
         data_size -= chunk->data_size;
         dest += chunk->data_size;
-        chunk = chunk->next_chunk ? (QXLDataChunk *)(chunk->next_chunk +
-                                                     worker->dev_info.phys_delta) : NULL;
+        chunk = chunk->next_chunk ?
+                (QXLDataChunk *)get_virt(worker, chunk->next_chunk, sizeof(QXLDataChunk)) : NULL;
     }
     red_set_cursor(worker, &local->base);
     red_release_cursor(worker, &local->base);
@@ -8415,6 +8699,7 @@ static void red_init(RedWorker *worker, WorkerInitData *init_data)
     worker->streaming_video = init_data->streaming_video;
     ring_init(&worker->current_list);
     ring_init(&worker->current);
+    ring_init(&worker->trusted_host_virts);
     image_cache_init(&worker->image_cache);
     drawables_init(worker);
     red_init_streams(worker);
@@ -8552,7 +8837,6 @@ static void dump_bitmap(RedWorker *worker, Bitmap *bitmap)
     uint32_t id;
     int row_size;
     uint32_t file_size;
-    long address_delta = worker->dev_info.phys_delta;
     int alpha = 0;
     uint32_t header_size = 14 + 40;
     uint32_t bitmap_data_offset;
@@ -8597,7 +8881,7 @@ static void dump_bitmap(RedWorker *worker, Bitmap *bitmap)
         if (!bitmap->palette) {
             return; // dont dump masks.
         }
-        plt = (Palette *)(bitmap->palette + address_delta);
+        plt = (Palette *)get_virt(worker, bitmap->palette, sizeof(Palette));
     }
     row_size = (((bitmap->x * n_pixel_bits) + 31) / 32) * 4;
     bitmap_data_offset = header_size;
@@ -8653,8 +8937,9 @@ static void dump_bitmap(RedWorker *worker, Bitmap *bitmap)
     }
     /* writing the data */
     if ((bitmap->flags & QXL_BITMAP_DIRECT)) {
-        uint8_t *lines = (uint8_t*)(bitmap->data + address_delta);
+        uint8_t *lines = (uint8_t*)get_virt(worker, bitmap->data, bitmap->stride * bitmap->y);
         int i;
+        check_mul_overflow(bitmap->stride, bitmap->y);
         for (i = 0; i < bitmap->y; i++) {
             dump_line(f, lines + (i * bitmap->stride), n_pixel_bits, bitmap->x, row_size);
         }
@@ -8665,7 +8950,8 @@ static void dump_bitmap(RedWorker *worker, Bitmap *bitmap)

         while (relative_address) {
             int i;
-            chunk = (QXLDataChunk *)(relative_address + address_delta);
+            chunk = (QXLDataChunk *)get_virt(worker, relative_address, sizeof(QXLDataChunk));
+            validate_virt(worker, chunk->data, chunk->data_size);
             num_lines = chunk->data_size / bitmap->stride;
             for (i = 0; i < num_lines; i++) {
                 dump_line(f, chunk->data + (i * bitmap->stride), n_pixel_bits, bitmap->x, row_size);
diff --git a/server/red_yuv.h b/server/red_yuv.h
index 9a2242c..340099f 100644
--- a/server/red_yuv.h
+++ b/server/red_yuv.h
@@ -83,9 +83,9 @@ static inline void FUNC_NAME(red_rgb_to_yuv420_line)(const uint8_t* line0, const
     }
 }

-static inline int FUNC_NAME(red_rgb_to_yuv420)(const Rect *src, const Bitmap *image,
-                                               AVFrame *frame, long phys_delta, int id,
-                                               Stream *stream)
+static inline int FUNC_NAME(red_rgb_to_yuv420)(RedWorker *worker, const Rect *src,
+                                               const Bitmap *image, AVFrame *frame,
+                                               long phys_delta, int id, Stream *stream)
 {
     QXLDataChunk *chunk;
     uint32_t image_stride;
@@ -107,14 +107,14 @@ static inline int FUNC_NAME(red_rgb_to_yuv420)(const Rect *src, const Bitmap *im

     const int skip_lines = stream->top_down ? src->top : image->y - (src->bottom - 0);
     for (i = 0; i < skip_lines; i++) {
-        red_get_image_line(&chunk, &offset, image_stride, phys_delta);
+        red_get_image_line(worker, &chunk, &offset, image_stride, phys_delta);
     }

     const int image_hight = src->bottom - src->top;
     const int image_width = src->right - src->left;
     for (i = 0; i < image_hight / 2; i++) {
-        uint8_t* line0 = red_get_image_line(&chunk, &offset, image_stride, phys_delta);
-        uint8_t* line1 = red_get_image_line(&chunk, &offset, image_stride, phys_delta);
+        uint8_t* line0 = red_get_image_line(worker, &chunk, &offset, image_stride, phys_delta);
+        uint8_t* line1 = red_get_image_line(worker, &chunk, &offset, image_stride, phys_delta);

         if (!line0 || !line1) {
             return FALSE;
@@ -131,7 +131,7 @@ static inline int FUNC_NAME(red_rgb_to_yuv420)(const Rect *src, const Bitmap *im
     }

     if ((image_hight & 1)) {
-        uint8_t* line = red_get_image_line(&chunk, &offset, image_stride, phys_delta);
+        uint8_t* line = red_get_image_line(worker, &chunk, &offset, image_stride, phys_delta);
         if (!line) {
             return FALSE;
         }
-- 
1.7.2

